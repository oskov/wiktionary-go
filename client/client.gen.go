// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for MediaItemType.
const (
	Audio MediaItemType = "audio"
	Image MediaItemType = "image"
	Video MediaItemType = "video"
)

// Defines values for GetCitationParamsFormat.
const (
	Bibtex              GetCitationParamsFormat = "bibtex"
	Mediawiki           GetCitationParamsFormat = "mediawiki"
	MediawikiBasefields GetCitationParamsFormat = "mediawiki-basefields"
	Wikibase            GetCitationParamsFormat = "wikibase"
	Zotero              GetCitationParamsFormat = "zotero"
)

// Defines values for GetDataCssMobileTypeParamsType.
const (
	GetDataCssMobileTypeParamsTypeBase    GetDataCssMobileTypeParamsType = "base"
	GetDataCssMobileTypeParamsTypePagelib GetDataCssMobileTypeParamsType = "pagelib"
	GetDataCssMobileTypeParamsTypePcs     GetDataCssMobileTypeParamsType = "pcs"
	GetDataCssMobileTypeParamsTypeSite    GetDataCssMobileTypeParamsType = "site"
)

// Defines values for GetDataI18nTypeParamsType.
const (
	GetDataI18nTypeParamsTypePcs GetDataI18nTypeParamsType = "pcs"
)

// Defines values for GetDataJavascriptMobileTypeParamsType.
const (
	Pagelib GetDataJavascriptMobileTypeParamsType = "pagelib"
	Pcs     GetDataJavascriptMobileTypeParamsType = "pcs"
)

// Defines values for GetDataListsParamsSort.
const (
	GetDataListsParamsSortName    GetDataListsParamsSort = "name"
	GetDataListsParamsSortUpdated GetDataListsParamsSort = "updated"
)

// Defines values for GetListEntriesParamsSort.
const (
	GetListEntriesParamsSortName    GetListEntriesParamsSort = "name"
	GetListEntriesParamsSortUpdated GetListEntriesParamsSort = "updated"
)

// Defines values for PostMediaMathCheckTypeParamsType.
const (
	Chem      PostMediaMathCheckTypeParamsType = "chem"
	InlineTex PostMediaMathCheckTypeParamsType = "inline-tex"
	Tex       PostMediaMathCheckTypeParamsType = "tex"
)

// Defines values for GetMediaMathRenderFormatHashParamsFormat.
const (
	Mml GetMediaMathRenderFormatHashParamsFormat = "mml"
	Png GetMediaMathRenderFormatHashParamsFormat = "png"
	Svg GetMediaMathRenderFormatHashParamsFormat = "svg"
)

// Defines values for TransformWikitextToMobileHtmlParamsOutputMode.
const (
	Content              TransformWikitextToMobileHtmlParamsOutputMode = "content"
	ContentAndReferences TransformWikitextToMobileHtmlParamsOutputMode = "contentAndReferences"
	EditPreview          TransformWikitextToMobileHtmlParamsOutputMode = "editPreview"
	References           TransformWikitextToMobileHtmlParamsOutputMode = "references"
)

// DataParsoid Result format for Parsoid data queries
type DataParsoid struct {
	Counter int32                  `json:"counter"`
	Ids     map[string]interface{} `json:"ids"`
}

// Definition Describes a single definition of a term
type Definition struct {
	// Definition A term definition
	Definition string    `json:"definition"`
	Examples   *[]string `json:"examples,omitempty"`
}

// DefinitionsResponse defines model for definitionsResponse.
type DefinitionsResponse struct {
	Usages []UsageDescription `json:"usages"`
}

// ListEntryRead defines model for list_entry_read.
type ListEntryRead struct {
	// Created Creation date (in ISO 8601)
	Created *time.Time `json:"created,omitempty"`
	Id      *int       `json:"id,omitempty"`

	// Project Domain of the wiki containing the page.
	Project *string `json:"project,omitempty"`

	// Title Title of the page containing the page, in database format.
	Title *string `json:"title,omitempty"`

	// Updated Last modification date (in ISO 8601)
	Updated *time.Time `json:"updated,omitempty"`
}

// ListEntryWrite defines model for list_entry_write.
type ListEntryWrite struct {
	// Project Domain of the wiki containing the page.
	Project string `json:"project"`

	// Title Title of the page containing the page, in database format.
	Title string `json:"title"`
}

// ListRead defines model for list_read.
type ListRead struct {
	// Created Creation date (in ISO 8601)
	Created     time.Time `json:"created"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`

	// Updated Last modification date (in ISO 8601)
	Updated time.Time `json:"updated"`
}

// ListWrite defines model for list_write.
type ListWrite struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// Listing The result format for listings
type Listing struct {
	Links *struct {
		Next *struct {
			// Href Relative link to next result page.
			Href *string `json:"href,omitempty"`
		} `json:"next,omitempty"`
	} `json:"_links,omitempty"`
	Items []string `json:"items"`
}

// MediaItem defines model for media_item.
type MediaItem struct {
	Caption *struct {
		// Html on-wiki caption for the media item, including all HTML markup
		Html *string `json:"html,omitempty"`

		// Text plain text of the on-wiki caption for the media item
		Text *string `json:"text,omitempty"`
	} `json:"caption,omitempty"`

	// Original reference to a Mathoid-rendered math formula image
	Original *struct {
		// Mime the Mathoid image mime type
		Mime *string `json:"mime,omitempty"`

		// Source Mathoid image render URL
		Source *string `json:"source,omitempty"`
	} `json:"original,omitempty"`

	// SectionId section ID in which the item is found on the page
	SectionId int `json:"section_id"`

	// ShowInGallery whether the client should show the file in an image gallery presentation
	ShowInGallery bool `json:"showInGallery"`

	// Title The file page title
	Title *string       `json:"title,omitempty"`
	Type  MediaItemType `json:"type"`
}

// MediaItemType defines model for MediaItem.Type.
type MediaItemType string

// MediaList defines model for media_list.
type MediaList struct {
	// Items a list of media items
	Items []MediaItem `json:"items"`

	// Revision the revision ID used to create the list
	Revision string `json:"revision"`

	// Tid the time uuid of the page rendering used to create the list
	Tid string `json:"tid"`
}

// Problem defines model for problem.
type Problem struct {
	Detail   *string `json:"detail,omitempty"`
	Instance *string `json:"instance,omitempty"`
	Title    *string `json:"title,omitempty"`
	Type     string  `json:"type"`
}

// Result defines model for result.
type Result struct {
	ItemType string `json:"itemType"`
	Title    string `json:"title"`
	Url      string `json:"url"`
}

// Revision Result format for revision items
type Revision struct {
	Count int32 `json:"count"`

	// Items Complete information about the revision
	Items RevisionInfo `json:"items"`
}

// RevisionInfo Complete information about the revision
type RevisionInfo struct {
	Comment      *string    `json:"comment,omitempty"`
	PageId       *int32     `json:"page_id,omitempty"`
	PageLanguage *string    `json:"page_language,omitempty"`
	Redirect     *bool      `json:"redirect,omitempty"`
	Restrictions *[]string  `json:"restrictions,omitempty"`
	Rev          *int32     `json:"rev,omitempty"`
	Tags         *[]string  `json:"tags,omitempty"`
	Tid          *string    `json:"tid,omitempty"`
	Timestamp    *time.Time `json:"timestamp,omitempty"`
	Title        *string    `json:"title,omitempty"`
	UserId       *int32     `json:"user_id,omitempty"`
	UserText     *string    `json:"user_text,omitempty"`
}

// UsageDescription defines model for usageDescription.
type UsageDescription struct {
	Definitions []Definition `json:"definitions"`

	// PartOfSpeech Part of speech (e.g. 'Noun' or 'Verb')
	PartOfSpeech string `json:"partOfSpeech"`
}

// GetCitationParams defines parameters for GetCitation.
type GetCitationParams struct {
	// AcceptLanguage For some articles the result depends on the `Accept-Language` header, so provide it if localized content is required.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetCitationParamsFormat defines parameters for GetCitation.
type GetCitationParamsFormat string

// GetDataCssMobileTypeParamsType defines parameters for GetDataCssMobileType.
type GetDataCssMobileTypeParamsType string

// GetDataI18nTypeParamsType defines parameters for GetDataI18nType.
type GetDataI18nTypeParamsType string

// GetDataJavascriptMobileTypeParamsType defines parameters for GetDataJavascriptMobileType.
type GetDataJavascriptMobileTypeParamsType string

// GetDataListsParams defines parameters for GetDataLists.
type GetDataListsParams struct {
	// Next Continuation parameter from previous request
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Sort Sort order
	// - `name`: by name, ascending;
	// - `updated`: by last modification date, descending.
	Sort *GetDataListsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetDataListsParamsSort defines parameters for GetDataLists.
type GetDataListsParamsSort string

// PostDataListsParams defines parameters for PostDataLists.
type PostDataListsParams struct {
	// CsrfToken The CRSF edit token provided by the MediaWiki API
	CsrfToken string `form:"csrf_token" json:"csrf_token"`
}

// PostDataListsBatchParams defines parameters for PostDataListsBatch.
type PostDataListsBatchParams struct {
	// CsrfToken The CRSF edit token provided by the MediaWiki API
	CsrfToken string `form:"csrf_token" json:"csrf_token"`
}

// GetDataListsChangesSinceDateParams defines parameters for GetDataListsChangesSinceDate.
type GetDataListsChangesSinceDateParams struct {
	// Next Continuation parameter from previous request
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// GetDataListsPagesProjectTitleParams defines parameters for GetDataListsPagesProjectTitle.
type GetDataListsPagesProjectTitleParams struct {
	// Next Continuation parameter from previous request
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// PostDataListsSetupParams defines parameters for PostDataListsSetup.
type PostDataListsSetupParams struct {
	// CsrfToken The CRSF edit token provided by the MediaWiki API
	CsrfToken string `form:"csrf_token" json:"csrf_token"`
}

// PostDataListsTeardownParams defines parameters for PostDataListsTeardown.
type PostDataListsTeardownParams struct {
	// CsrfToken The CRSF edit token provided by the MediaWiki API
	CsrfToken string `form:"csrf_token" json:"csrf_token"`
}

// PutDataListsIdParams defines parameters for PutDataListsId.
type PutDataListsIdParams struct {
	// CsrfToken The CRSF edit token provided by the MediaWiki API
	CsrfToken string `form:"csrf_token" json:"csrf_token"`
}

// GetListEntriesParams defines parameters for GetListEntries.
type GetListEntriesParams struct {
	// Next Continuation parameter from previous request
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Sort Sort order
	// - `name`: by page title, ascending;
	// - `updated`: by last modification date, descending.
	Sort *GetListEntriesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetListEntriesParamsSort defines parameters for GetListEntries.
type GetListEntriesParamsSort string

// PostDataListsIdEntriesParams defines parameters for PostDataListsIdEntries.
type PostDataListsIdEntriesParams struct {
	// CsrfToken The CRSF edit token provided by the MediaWiki API
	CsrfToken string `form:"csrf_token" json:"csrf_token"`
}

// PostDataListsIdEntriesBatchParams defines parameters for PostDataListsIdEntriesBatch.
type PostDataListsIdEntriesBatchParams struct {
	// CsrfToken The CRSF edit token provided by the MediaWiki API
	CsrfToken string `form:"csrf_token" json:"csrf_token"`
}

// PostMediaMathCheckTypeMultipartBody defines parameters for PostMediaMathCheckType.
type PostMediaMathCheckTypeMultipartBody struct {
	// Q The formula to check
	Q string `json:"q"`
}

// PostMediaMathCheckTypeParamsType defines parameters for PostMediaMathCheckType.
type PostMediaMathCheckTypeParamsType string

// GetMediaMathRenderFormatHashParamsFormat defines parameters for GetMediaMathRenderFormatHash.
type GetMediaMathRenderFormatHashParamsFormat string

// GetPageDataParsoidTitleRevisionTidParams defines parameters for GetPageDataParsoidTitleRevisionTid.
type GetPageDataParsoidTitleRevisionTidParams struct {
	// Redirect Requests for [redirect pages](https://www.mediawiki.org/wiki/Help:Redirects) return HTTP 302 with a redirect target in `Location` header and content in the body.
	// To get a 200 response instead, supply `false` to the `redirect` parameter.
	Redirect *bool `form:"redirect,omitempty" json:"redirect,omitempty"`
}

// GetPageDefinitionTermParams defines parameters for GetPageDefinitionTerm.
type GetPageDefinitionTermParams struct {
	// Redirect Requests for [redirect pages](https://www.mediawiki.org/wiki/Help:Redirects) return HTTP 302 with a redirect target in `Location` header and content in the body.
	// To get a 200 response instead, supply `false` to the `redirect` parameter.
	Redirect *bool `form:"redirect,omitempty" json:"redirect,omitempty"`
}

// GetPageHtmlTitleParams defines parameters for GetPageHtmlTitle.
type GetPageHtmlTitleParams struct {
	// Redirect Requests for [redirect pages](https://www.mediawiki.org/wiki/Help:Redirects) return HTTP 302 with a redirect target in `Location` header and content in the body.
	// To get a 200 response instead, supply `false` to the `redirect` parameter.
	Redirect *bool `form:"redirect,omitempty" json:"redirect,omitempty"`

	// Stash Whether to temporary stash data-parsoid in order to support transforming the
	// modified content later. If this parameter is set, requests are rate-limited on
	// a per-client basis (max 5 requests per second per client)
	Stash *bool `form:"stash,omitempty" json:"stash,omitempty"`

	// AcceptLanguage The desired language variant code for wikis where LanguageConverter is enabled. Example: `sr-el` for Latin transcription of the Serbian language.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetFormatRevisionParams defines parameters for GetFormatRevision.
type GetFormatRevisionParams struct {
	// Redirect Requests for [redirect pages](https://www.mediawiki.org/wiki/Help:Redirects) return HTTP 302 with a redirect target in `Location` header and content in the body.
	// To get a 200 response instead, supply `false` to the `redirect` parameter.
	Redirect *bool `form:"redirect,omitempty" json:"redirect,omitempty"`

	// Stash Whether to temporary stash data-parsoid in order to support transforming the
	// modified content later. If this parameter is set, requests are rate-limited on
	// a per-client basis (max 5 requests per second per client)
	Stash *bool `form:"stash,omitempty" json:"stash,omitempty"`

	// AcceptLanguage The desired language variant code for wikis where LanguageConverter is enabled. Example: `sr-el` for Latin transcription of the Serbian language.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetContentMediaListParams defines parameters for GetContentMediaList.
type GetContentMediaListParams struct {
	// Redirect Requests for [redirect pages](https://www.mediawiki.org/wiki/Help:Redirects) return HTTP 302 with a redirect target in `Location` header and content in the body.
	// To get a 200 response instead, supply `false` to the `redirect` parameter.
	Redirect *bool `form:"redirect,omitempty" json:"redirect,omitempty"`
}

// GetContentWithRevisionMediaListParams defines parameters for GetContentWithRevisionMediaList.
type GetContentWithRevisionMediaListParams struct {
	// Redirect Requests for [redirect pages](https://www.mediawiki.org/wiki/Help:Redirects) return HTTP 302 with a redirect target in `Location` header and content in the body.
	// To get a 200 response instead, supply `false` to the `redirect` parameter.
	Redirect *bool `form:"redirect,omitempty" json:"redirect,omitempty"`
}

// GetContentMobileHtmlParams defines parameters for GetContentMobileHtml.
type GetContentMobileHtmlParams struct {
	// Redirect Requests for [redirect pages](https://www.mediawiki.org/wiki/Help:Redirects) return HTTP 302 with a redirect target in `Location` header and content in the body.
	// To get a 200 response instead, supply `false` to the `redirect` parameter.
	Redirect *bool `form:"redirect,omitempty" json:"redirect,omitempty"`
}

// GetContentWithRevisionMobileHtmlParams defines parameters for GetContentWithRevisionMobileHtml.
type GetContentWithRevisionMobileHtmlParams struct {
	// Redirect Requests for [redirect pages](https://www.mediawiki.org/wiki/Help:Redirects) return HTTP 302 with a redirect target in `Location` header and content in the body.
	// To get a 200 response instead, supply `false` to the `redirect` parameter.
	Redirect *bool `form:"redirect,omitempty" json:"redirect,omitempty"`
}

// PostTransformHtmlToWikitextMultipartBody defines parameters for PostTransformHtmlToWikitext.
type PostTransformHtmlToWikitextMultipartBody struct {
	// Html The HTML to transform
	Html string `json:"html"`

	// ScrubWikitext Normalise the DOM to yield cleaner wikitext?
	ScrubWikitext *bool `json:"scrub_wikitext,omitempty"`
}

// PostTransformHtmlToWikitextParams defines parameters for PostTransformHtmlToWikitext.
type PostTransformHtmlToWikitextParams struct {
	// IfMatch The `ETag` header of the original render indicating it's revision and timeuuid.
	// Required if both `title` and `revision` parameters are present.
	IfMatch *string `json:"if-match,omitempty"`
}

// PostTransformHtmlToWikitextTitleMultipartBody defines parameters for PostTransformHtmlToWikitextTitle.
type PostTransformHtmlToWikitextTitleMultipartBody struct {
	// Html The HTML to transform
	Html string `json:"html"`

	// ScrubWikitext Normalise the DOM to yield cleaner wikitext?
	ScrubWikitext *bool `json:"scrub_wikitext,omitempty"`
}

// PostTransformHtmlToWikitextTitleParams defines parameters for PostTransformHtmlToWikitextTitle.
type PostTransformHtmlToWikitextTitleParams struct {
	// IfMatch The `ETag` header of the original render indicating it's revision and timeuuid.
	// Required if both `title` and `revision` parameters are present.
	IfMatch *string `json:"if-match,omitempty"`
}

// PostTransformHtmlToWikitextTitleRevisionMultipartBody defines parameters for PostTransformHtmlToWikitextTitleRevision.
type PostTransformHtmlToWikitextTitleRevisionMultipartBody struct {
	// Html The HTML to transform
	Html string `json:"html"`

	// ScrubWikitext Normalise the DOM to yield cleaner wikitext?
	ScrubWikitext *bool `json:"scrub_wikitext,omitempty"`
}

// PostTransformHtmlToWikitextTitleRevisionParams defines parameters for PostTransformHtmlToWikitextTitleRevision.
type PostTransformHtmlToWikitextTitleRevisionParams struct {
	// IfMatch The `ETag` header of the original render indicating it's revision and timeuuid.
	// Required if both `title` and `revision` parameters are present.
	IfMatch *string `json:"if-match,omitempty"`
}

// PostTransformWikitextToHtmlMultipartBody defines parameters for PostTransformWikitextToHtml.
type PostTransformWikitextToHtmlMultipartBody struct {
	// BodyOnly Return only `body.innerHTML`
	BodyOnly *bool `json:"body_only,omitempty"`

	// Stash Whether to temporarily stash the result of the transformation
	Stash *bool `json:"stash,omitempty"`

	// Wikitext The Wikitext to transform to HTML
	Wikitext string `json:"wikitext"`
}

// PostTransformWikitextToHtmlTitleMultipartBody defines parameters for PostTransformWikitextToHtmlTitle.
type PostTransformWikitextToHtmlTitleMultipartBody struct {
	// BodyOnly Return only `body.innerHTML`
	BodyOnly *bool `json:"body_only,omitempty"`

	// Stash Whether to temporarily stash the result of the transformation
	Stash *bool `json:"stash,omitempty"`

	// Wikitext The Wikitext to transform to HTML
	Wikitext string `json:"wikitext"`
}

// PostTransformWikitextToHtmlTitleRevisionMultipartBody defines parameters for PostTransformWikitextToHtmlTitleRevision.
type PostTransformWikitextToHtmlTitleRevisionMultipartBody struct {
	// BodyOnly Return only `body.innerHTML`
	BodyOnly *bool `json:"body_only,omitempty"`

	// Stash Whether to temporarily stash the result of the transformation
	Stash *bool `json:"stash,omitempty"`

	// Wikitext The Wikitext to transform to HTML
	Wikitext string `json:"wikitext"`
}

// PostTransformWikitextToLintJSONBody defines parameters for PostTransformWikitextToLint.
type PostTransformWikitextToLintJSONBody struct {
	// Wikitext The Wikitext to check
	Wikitext string `json:"wikitext"`
}

// PostTransformWikitextToLintMultipartBody defines parameters for PostTransformWikitextToLint.
type PostTransformWikitextToLintMultipartBody struct {
	// Wikitext The Wikitext to check
	Wikitext string `json:"wikitext"`
}

// PostTransformWikitextToLintTitleMultipartBody defines parameters for PostTransformWikitextToLintTitle.
type PostTransformWikitextToLintTitleMultipartBody struct {
	// Wikitext The Wikitext to check
	Wikitext string `json:"wikitext"`
}

// PostTransformWikitextToLintTitleRevisionMultipartBody defines parameters for PostTransformWikitextToLintTitleRevision.
type PostTransformWikitextToLintTitleRevisionMultipartBody struct {
	// Wikitext The Wikitext to check
	Wikitext string `json:"wikitext"`
}

// TransformWikitextToMobileHtmlMultipartBody defines parameters for TransformWikitextToMobileHtml.
type TransformWikitextToMobileHtmlMultipartBody struct {
	// Wikitext The Wikitext to transform to HTML
	Wikitext string `json:"wikitext"`
}

// TransformWikitextToMobileHtmlParams defines parameters for TransformWikitextToMobileHtml.
type TransformWikitextToMobileHtmlParams struct {
	// AcceptLanguage The desired language variant code for wikis where LanguageConverter is enabled. Example: `sr-el` for Latin transcription of the Serbian language.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`

	// OutputMode Output mode for mobile-html. Default is `editPreview`.
	OutputMode *TransformWikitextToMobileHtmlParamsOutputMode `json:"output-mode,omitempty"`
}

// TransformWikitextToMobileHtmlParamsOutputMode defines parameters for TransformWikitextToMobileHtml.
type TransformWikitextToMobileHtmlParamsOutputMode string

// PostMediaMathCheckTypeMultipartRequestBody defines body for PostMediaMathCheckType for multipart/form-data ContentType.
type PostMediaMathCheckTypeMultipartRequestBody PostMediaMathCheckTypeMultipartBody

// PostTransformHtmlToWikitextMultipartRequestBody defines body for PostTransformHtmlToWikitext for multipart/form-data ContentType.
type PostTransformHtmlToWikitextMultipartRequestBody PostTransformHtmlToWikitextMultipartBody

// PostTransformHtmlToWikitextTitleMultipartRequestBody defines body for PostTransformHtmlToWikitextTitle for multipart/form-data ContentType.
type PostTransformHtmlToWikitextTitleMultipartRequestBody PostTransformHtmlToWikitextTitleMultipartBody

// PostTransformHtmlToWikitextTitleRevisionMultipartRequestBody defines body for PostTransformHtmlToWikitextTitleRevision for multipart/form-data ContentType.
type PostTransformHtmlToWikitextTitleRevisionMultipartRequestBody PostTransformHtmlToWikitextTitleRevisionMultipartBody

// PostTransformWikitextToHtmlMultipartRequestBody defines body for PostTransformWikitextToHtml for multipart/form-data ContentType.
type PostTransformWikitextToHtmlMultipartRequestBody PostTransformWikitextToHtmlMultipartBody

// PostTransformWikitextToHtmlTitleMultipartRequestBody defines body for PostTransformWikitextToHtmlTitle for multipart/form-data ContentType.
type PostTransformWikitextToHtmlTitleMultipartRequestBody PostTransformWikitextToHtmlTitleMultipartBody

// PostTransformWikitextToHtmlTitleRevisionMultipartRequestBody defines body for PostTransformWikitextToHtmlTitleRevision for multipart/form-data ContentType.
type PostTransformWikitextToHtmlTitleRevisionMultipartRequestBody PostTransformWikitextToHtmlTitleRevisionMultipartBody

// PostTransformWikitextToLintJSONRequestBody defines body for PostTransformWikitextToLint for application/json ContentType.
type PostTransformWikitextToLintJSONRequestBody PostTransformWikitextToLintJSONBody

// PostTransformWikitextToLintMultipartRequestBody defines body for PostTransformWikitextToLint for multipart/form-data ContentType.
type PostTransformWikitextToLintMultipartRequestBody PostTransformWikitextToLintMultipartBody

// PostTransformWikitextToLintTitleMultipartRequestBody defines body for PostTransformWikitextToLintTitle for multipart/form-data ContentType.
type PostTransformWikitextToLintTitleMultipartRequestBody PostTransformWikitextToLintTitleMultipartBody

// PostTransformWikitextToLintTitleRevisionMultipartRequestBody defines body for PostTransformWikitextToLintTitleRevision for multipart/form-data ContentType.
type PostTransformWikitextToLintTitleRevisionMultipartRequestBody PostTransformWikitextToLintTitleRevisionMultipartBody

// TransformWikitextToMobileHtmlMultipartRequestBody defines body for TransformWikitextToMobileHtml for multipart/form-data ContentType.
type TransformWikitextToMobileHtmlMultipartRequestBody TransformWikitextToMobileHtmlMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCitation request
	GetCitation(ctx context.Context, format GetCitationParamsFormat, query string, params *GetCitationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataCssMobileType request
	GetDataCssMobileType(ctx context.Context, pType GetDataCssMobileTypeParamsType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataI18nType request
	GetDataI18nType(ctx context.Context, pType GetDataI18nTypeParamsType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataJavascriptMobileType request
	GetDataJavascriptMobileType(ctx context.Context, pType GetDataJavascriptMobileTypeParamsType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataLists request
	GetDataLists(ctx context.Context, params *GetDataListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDataListsWithBody request with any body
	PostDataListsWithBody(ctx context.Context, params *PostDataListsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDataListsBatchWithBody request with any body
	PostDataListsBatchWithBody(ctx context.Context, params *PostDataListsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataListsChangesSinceDate request
	GetDataListsChangesSinceDate(ctx context.Context, date time.Time, params *GetDataListsChangesSinceDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataListsPagesProjectTitle request
	GetDataListsPagesProjectTitle(ctx context.Context, project string, title string, params *GetDataListsPagesProjectTitleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDataListsSetup request
	PostDataListsSetup(ctx context.Context, params *PostDataListsSetupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDataListsTeardown request
	PostDataListsTeardown(ctx context.Context, params *PostDataListsTeardownParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataListsId request
	DeleteDataListsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDataListsIdWithBody request with any body
	PutDataListsIdWithBody(ctx context.Context, id int, params *PutDataListsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListEntries request
	GetListEntries(ctx context.Context, id int, params *GetListEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDataListsIdEntriesWithBody request with any body
	PostDataListsIdEntriesWithBody(ctx context.Context, id int, params *PostDataListsIdEntriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDataListsIdEntriesBatchWithBody request with any body
	PostDataListsIdEntriesBatchWithBody(ctx context.Context, id int, params *PostDataListsIdEntriesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataListsIdEntriesEntryId request
	DeleteDataListsIdEntriesEntryId(ctx context.Context, id int, entryId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMediaMathCheckTypeWithBody request with any body
	PostMediaMathCheckTypeWithBody(ctx context.Context, pType PostMediaMathCheckTypeParamsType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaMathFormulaHash request
	GetMediaMathFormulaHash(ctx context.Context, hash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaMathRenderFormatHash request
	GetMediaMathRenderFormatHash(ctx context.Context, format GetMediaMathRenderFormatHashParamsFormat, hash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPage request
	GetPage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageDataParsoidTitleRevisionTid request
	GetPageDataParsoidTitleRevisionTid(ctx context.Context, title string, revision int, tid string, params *GetPageDataParsoidTitleRevisionTidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageDefinitionTerm request
	GetPageDefinitionTerm(ctx context.Context, term string, params *GetPageDefinitionTermParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageHtmlTitle request
	GetPageHtmlTitle(ctx context.Context, title string, params *GetPageHtmlTitleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFormatRevision request
	GetFormatRevision(ctx context.Context, title string, revision int, params *GetFormatRevisionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageLintTitle request
	GetPageLintTitle(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageLintTitleRevision request
	GetPageLintTitleRevision(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentMediaList request
	GetContentMediaList(ctx context.Context, title string, params *GetContentMediaListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentWithRevisionMediaList request
	GetContentWithRevisionMediaList(ctx context.Context, title string, revision int, params *GetContentWithRevisionMediaListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageMobileHtmlOfflineResourcesTitle request
	GetPageMobileHtmlOfflineResourcesTitle(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageMobileHtmlOfflineResourcesTitleRevision request
	GetPageMobileHtmlOfflineResourcesTitleRevision(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentMobileHtml request
	GetContentMobileHtml(ctx context.Context, title string, params *GetContentMobileHtmlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentWithRevisionMobileHtml request
	GetContentWithRevisionMobileHtml(ctx context.Context, title string, revision int, params *GetContentWithRevisionMobileHtmlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageTitleTitle request
	GetPageTitleTitle(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageTitleTitleRevision request
	GetPageTitleTitleRevision(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformHtmlToWikitextWithBody request with any body
	PostTransformHtmlToWikitextWithBody(ctx context.Context, params *PostTransformHtmlToWikitextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformHtmlToWikitextTitleWithBody request with any body
	PostTransformHtmlToWikitextTitleWithBody(ctx context.Context, title string, params *PostTransformHtmlToWikitextTitleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformHtmlToWikitextTitleRevisionWithBody request with any body
	PostTransformHtmlToWikitextTitleRevisionWithBody(ctx context.Context, title string, revision int, params *PostTransformHtmlToWikitextTitleRevisionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformWikitextToHtmlWithBody request with any body
	PostTransformWikitextToHtmlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformWikitextToHtmlTitleWithBody request with any body
	PostTransformWikitextToHtmlTitleWithBody(ctx context.Context, title string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformWikitextToHtmlTitleRevisionWithBody request with any body
	PostTransformWikitextToHtmlTitleRevisionWithBody(ctx context.Context, title string, revision int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformWikitextToLintWithBody request with any body
	PostTransformWikitextToLintWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTransformWikitextToLint(ctx context.Context, body PostTransformWikitextToLintJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformWikitextToLintTitleWithBody request with any body
	PostTransformWikitextToLintTitleWithBody(ctx context.Context, title string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransformWikitextToLintTitleRevisionWithBody request with any body
	PostTransformWikitextToLintTitleRevisionWithBody(ctx context.Context, title string, revision int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransformWikitextToMobileHtmlWithBody request with any body
	TransformWikitextToMobileHtmlWithBody(ctx context.Context, title string, params *TransformWikitextToMobileHtmlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCitation(ctx context.Context, format GetCitationParamsFormat, query string, params *GetCitationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCitationRequest(c.Server, format, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataCssMobileType(ctx context.Context, pType GetDataCssMobileTypeParamsType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataCssMobileTypeRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataI18nType(ctx context.Context, pType GetDataI18nTypeParamsType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataI18nTypeRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataJavascriptMobileType(ctx context.Context, pType GetDataJavascriptMobileTypeParamsType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataJavascriptMobileTypeRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataLists(ctx context.Context, params *GetDataListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataListsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDataListsWithBody(ctx context.Context, params *PostDataListsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDataListsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDataListsBatchWithBody(ctx context.Context, params *PostDataListsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDataListsBatchRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataListsChangesSinceDate(ctx context.Context, date time.Time, params *GetDataListsChangesSinceDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataListsChangesSinceDateRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataListsPagesProjectTitle(ctx context.Context, project string, title string, params *GetDataListsPagesProjectTitleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataListsPagesProjectTitleRequest(c.Server, project, title, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDataListsSetup(ctx context.Context, params *PostDataListsSetupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDataListsSetupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDataListsTeardown(ctx context.Context, params *PostDataListsTeardownParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDataListsTeardownRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataListsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataListsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDataListsIdWithBody(ctx context.Context, id int, params *PutDataListsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDataListsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListEntries(ctx context.Context, id int, params *GetListEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListEntriesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDataListsIdEntriesWithBody(ctx context.Context, id int, params *PostDataListsIdEntriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDataListsIdEntriesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDataListsIdEntriesBatchWithBody(ctx context.Context, id int, params *PostDataListsIdEntriesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDataListsIdEntriesBatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataListsIdEntriesEntryId(ctx context.Context, id int, entryId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataListsIdEntriesEntryIdRequest(c.Server, id, entryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMediaMathCheckTypeWithBody(ctx context.Context, pType PostMediaMathCheckTypeParamsType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMediaMathCheckTypeRequestWithBody(c.Server, pType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaMathFormulaHash(ctx context.Context, hash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaMathFormulaHashRequest(c.Server, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaMathRenderFormatHash(ctx context.Context, format GetMediaMathRenderFormatHashParamsFormat, hash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaMathRenderFormatHashRequest(c.Server, format, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageDataParsoidTitleRevisionTid(ctx context.Context, title string, revision int, tid string, params *GetPageDataParsoidTitleRevisionTidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageDataParsoidTitleRevisionTidRequest(c.Server, title, revision, tid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageDefinitionTerm(ctx context.Context, term string, params *GetPageDefinitionTermParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageDefinitionTermRequest(c.Server, term, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageHtmlTitle(ctx context.Context, title string, params *GetPageHtmlTitleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageHtmlTitleRequest(c.Server, title, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFormatRevision(ctx context.Context, title string, revision int, params *GetFormatRevisionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFormatRevisionRequest(c.Server, title, revision, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageLintTitle(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageLintTitleRequest(c.Server, title)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageLintTitleRevision(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageLintTitleRevisionRequest(c.Server, title, revision)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentMediaList(ctx context.Context, title string, params *GetContentMediaListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentMediaListRequest(c.Server, title, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentWithRevisionMediaList(ctx context.Context, title string, revision int, params *GetContentWithRevisionMediaListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentWithRevisionMediaListRequest(c.Server, title, revision, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageMobileHtmlOfflineResourcesTitle(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageMobileHtmlOfflineResourcesTitleRequest(c.Server, title)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageMobileHtmlOfflineResourcesTitleRevision(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageMobileHtmlOfflineResourcesTitleRevisionRequest(c.Server, title, revision)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentMobileHtml(ctx context.Context, title string, params *GetContentMobileHtmlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentMobileHtmlRequest(c.Server, title, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentWithRevisionMobileHtml(ctx context.Context, title string, revision int, params *GetContentWithRevisionMobileHtmlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentWithRevisionMobileHtmlRequest(c.Server, title, revision, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageTitleTitle(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageTitleTitleRequest(c.Server, title)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageTitleTitleRevision(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageTitleTitleRevisionRequest(c.Server, title, revision)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformHtmlToWikitextWithBody(ctx context.Context, params *PostTransformHtmlToWikitextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformHtmlToWikitextRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformHtmlToWikitextTitleWithBody(ctx context.Context, title string, params *PostTransformHtmlToWikitextTitleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformHtmlToWikitextTitleRequestWithBody(c.Server, title, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformHtmlToWikitextTitleRevisionWithBody(ctx context.Context, title string, revision int, params *PostTransformHtmlToWikitextTitleRevisionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformHtmlToWikitextTitleRevisionRequestWithBody(c.Server, title, revision, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformWikitextToHtmlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformWikitextToHtmlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformWikitextToHtmlTitleWithBody(ctx context.Context, title string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformWikitextToHtmlTitleRequestWithBody(c.Server, title, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformWikitextToHtmlTitleRevisionWithBody(ctx context.Context, title string, revision int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformWikitextToHtmlTitleRevisionRequestWithBody(c.Server, title, revision, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformWikitextToLintWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformWikitextToLintRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformWikitextToLint(ctx context.Context, body PostTransformWikitextToLintJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformWikitextToLintRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformWikitextToLintTitleWithBody(ctx context.Context, title string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformWikitextToLintTitleRequestWithBody(c.Server, title, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransformWikitextToLintTitleRevisionWithBody(ctx context.Context, title string, revision int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransformWikitextToLintTitleRevisionRequestWithBody(c.Server, title, revision, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransformWikitextToMobileHtmlWithBody(ctx context.Context, title string, params *TransformWikitextToMobileHtmlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransformWikitextToMobileHtmlRequestWithBody(c.Server, title, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCitationRequest generates requests for GetCitation
func NewGetCitationRequest(server string, format GetCitationParamsFormat, query string, params *GetCitationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "format", runtime.ParamLocationPath, format)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/citation/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetDataCssMobileTypeRequest generates requests for GetDataCssMobileType
func NewGetDataCssMobileTypeRequest(server string, pType GetDataCssMobileTypeParamsType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/css/mobile/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataI18nTypeRequest generates requests for GetDataI18nType
func NewGetDataI18nTypeRequest(server string, pType GetDataI18nTypeParamsType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/i18n/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataJavascriptMobileTypeRequest generates requests for GetDataJavascriptMobileType
func NewGetDataJavascriptMobileTypeRequest(server string, pType GetDataJavascriptMobileTypeParamsType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/javascript/mobile/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataListsRequest generates requests for GetDataLists
func NewGetDataListsRequest(server string, params *GetDataListsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDataListsRequestWithBody generates requests for PostDataLists with any type of body
func NewPostDataListsRequestWithBody(server string, params *PostDataListsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csrf_token", runtime.ParamLocationQuery, params.CsrfToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDataListsBatchRequestWithBody generates requests for PostDataListsBatch with any type of body
func NewPostDataListsBatchRequestWithBody(server string, params *PostDataListsBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csrf_token", runtime.ParamLocationQuery, params.CsrfToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDataListsChangesSinceDateRequest generates requests for GetDataListsChangesSinceDate
func NewGetDataListsChangesSinceDateRequest(server string, date time.Time, params *GetDataListsChangesSinceDateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/changes/since/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataListsPagesProjectTitleRequest generates requests for GetDataListsPagesProjectTitle
func NewGetDataListsPagesProjectTitleRequest(server string, project string, title string, params *GetDataListsPagesProjectTitleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/pages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDataListsSetupRequest generates requests for PostDataListsSetup
func NewPostDataListsSetupRequest(server string, params *PostDataListsSetupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/setup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csrf_token", runtime.ParamLocationQuery, params.CsrfToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDataListsTeardownRequest generates requests for PostDataListsTeardown
func NewPostDataListsTeardownRequest(server string, params *PostDataListsTeardownParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/teardown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csrf_token", runtime.ParamLocationQuery, params.CsrfToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDataListsIdRequest generates requests for DeleteDataListsId
func NewDeleteDataListsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutDataListsIdRequestWithBody generates requests for PutDataListsId with any type of body
func NewPutDataListsIdRequestWithBody(server string, id int, params *PutDataListsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csrf_token", runtime.ParamLocationQuery, params.CsrfToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetListEntriesRequest generates requests for GetListEntries
func NewGetListEntriesRequest(server string, id int, params *GetListEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/%s/entries/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDataListsIdEntriesRequestWithBody generates requests for PostDataListsIdEntries with any type of body
func NewPostDataListsIdEntriesRequestWithBody(server string, id int, params *PostDataListsIdEntriesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/%s/entries/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csrf_token", runtime.ParamLocationQuery, params.CsrfToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDataListsIdEntriesBatchRequestWithBody generates requests for PostDataListsIdEntriesBatch with any type of body
func NewPostDataListsIdEntriesBatchRequestWithBody(server string, id int, params *PostDataListsIdEntriesBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/%s/entries/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csrf_token", runtime.ParamLocationQuery, params.CsrfToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDataListsIdEntriesEntryIdRequest generates requests for DeleteDataListsIdEntriesEntryId
func NewDeleteDataListsIdEntriesEntryIdRequest(server string, id int, entryId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entry_id", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/lists/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMediaMathCheckTypeRequestWithBody generates requests for PostMediaMathCheckType with any type of body
func NewPostMediaMathCheckTypeRequestWithBody(server string, pType PostMediaMathCheckTypeParamsType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/media/math/check/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMediaMathFormulaHashRequest generates requests for GetMediaMathFormulaHash
func NewGetMediaMathFormulaHashRequest(server string, hash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/media/math/formula/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMediaMathRenderFormatHashRequest generates requests for GetMediaMathRenderFormatHash
func NewGetMediaMathRenderFormatHashRequest(server string, format GetMediaMathRenderFormatHashParamsFormat, hash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "format", runtime.ParamLocationPath, format)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/media/math/render/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageRequest generates requests for GetPage
func NewGetPageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageDataParsoidTitleRevisionTidRequest generates requests for GetPageDataParsoidTitleRevisionTid
func NewGetPageDataParsoidTitleRevisionTidRequest(server string, title string, revision int, tid string, params *GetPageDataParsoidTitleRevisionTidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tid", runtime.ParamLocationPath, tid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/data-parsoid/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageDefinitionTermRequest generates requests for GetPageDefinitionTerm
func NewGetPageDefinitionTermRequest(server string, term string, params *GetPageDefinitionTermParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "term", runtime.ParamLocationPath, term)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/definition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageHtmlTitleRequest generates requests for GetPageHtmlTitle
func NewGetPageHtmlTitleRequest(server string, title string, params *GetPageHtmlTitleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/html/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stash", runtime.ParamLocationQuery, *params.Stash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetFormatRevisionRequest generates requests for GetFormatRevision
func NewGetFormatRevisionRequest(server string, title string, revision int, params *GetFormatRevisionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/html/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stash", runtime.ParamLocationQuery, *params.Stash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetPageLintTitleRequest generates requests for GetPageLintTitle
func NewGetPageLintTitleRequest(server string, title string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/lint/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageLintTitleRevisionRequest generates requests for GetPageLintTitleRevision
func NewGetPageLintTitleRevisionRequest(server string, title string, revision int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/lint/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentMediaListRequest generates requests for GetContentMediaList
func NewGetContentMediaListRequest(server string, title string, params *GetContentMediaListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/media-list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentWithRevisionMediaListRequest generates requests for GetContentWithRevisionMediaList
func NewGetContentWithRevisionMediaListRequest(server string, title string, revision int, params *GetContentWithRevisionMediaListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/media-list/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageMobileHtmlOfflineResourcesTitleRequest generates requests for GetPageMobileHtmlOfflineResourcesTitle
func NewGetPageMobileHtmlOfflineResourcesTitleRequest(server string, title string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/mobile-html-offline-resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageMobileHtmlOfflineResourcesTitleRevisionRequest generates requests for GetPageMobileHtmlOfflineResourcesTitleRevision
func NewGetPageMobileHtmlOfflineResourcesTitleRevisionRequest(server string, title string, revision int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/mobile-html-offline-resources/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentMobileHtmlRequest generates requests for GetContentMobileHtml
func NewGetContentMobileHtmlRequest(server string, title string, params *GetContentMobileHtmlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/mobile-html/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentWithRevisionMobileHtmlRequest generates requests for GetContentWithRevisionMobileHtml
func NewGetContentWithRevisionMobileHtmlRequest(server string, title string, revision int, params *GetContentWithRevisionMobileHtmlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/mobile-html/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect", runtime.ParamLocationQuery, *params.Redirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageTitleTitleRequest generates requests for GetPageTitleTitle
func NewGetPageTitleTitleRequest(server string, title string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/title/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageTitleTitleRevisionRequest generates requests for GetPageTitleTitleRevision
func NewGetPageTitleTitleRevisionRequest(server string, title string, revision int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/page/title/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTransformHtmlToWikitextRequestWithBody generates requests for PostTransformHtmlToWikitext with any type of body
func NewPostTransformHtmlToWikitextRequestWithBody(server string, params *PostTransformHtmlToWikitextParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/html/to/wikitext")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-match", headerParam0)
		}

	}

	return req, nil
}

// NewPostTransformHtmlToWikitextTitleRequestWithBody generates requests for PostTransformHtmlToWikitextTitle with any type of body
func NewPostTransformHtmlToWikitextTitleRequestWithBody(server string, title string, params *PostTransformHtmlToWikitextTitleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/html/to/wikitext/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-match", headerParam0)
		}

	}

	return req, nil
}

// NewPostTransformHtmlToWikitextTitleRevisionRequestWithBody generates requests for PostTransformHtmlToWikitextTitleRevision with any type of body
func NewPostTransformHtmlToWikitextTitleRevisionRequestWithBody(server string, title string, revision int, params *PostTransformHtmlToWikitextTitleRevisionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/html/to/wikitext/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-match", headerParam0)
		}

	}

	return req, nil
}

// NewPostTransformWikitextToHtmlRequestWithBody generates requests for PostTransformWikitextToHtml with any type of body
func NewPostTransformWikitextToHtmlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/wikitext/to/html")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTransformWikitextToHtmlTitleRequestWithBody generates requests for PostTransformWikitextToHtmlTitle with any type of body
func NewPostTransformWikitextToHtmlTitleRequestWithBody(server string, title string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/wikitext/to/html/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTransformWikitextToHtmlTitleRevisionRequestWithBody generates requests for PostTransformWikitextToHtmlTitleRevision with any type of body
func NewPostTransformWikitextToHtmlTitleRevisionRequestWithBody(server string, title string, revision int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/wikitext/to/html/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTransformWikitextToLintRequest calls the generic PostTransformWikitextToLint builder with application/json body
func NewPostTransformWikitextToLintRequest(server string, body PostTransformWikitextToLintJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTransformWikitextToLintRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTransformWikitextToLintRequestWithBody generates requests for PostTransformWikitextToLint with any type of body
func NewPostTransformWikitextToLintRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/wikitext/to/lint")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTransformWikitextToLintTitleRequestWithBody generates requests for PostTransformWikitextToLintTitle with any type of body
func NewPostTransformWikitextToLintTitleRequestWithBody(server string, title string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/wikitext/to/lint/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTransformWikitextToLintTitleRevisionRequestWithBody generates requests for PostTransformWikitextToLintTitleRevision with any type of body
func NewPostTransformWikitextToLintTitleRevisionRequestWithBody(server string, title string, revision int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/wikitext/to/lint/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransformWikitextToMobileHtmlRequestWithBody generates requests for TransformWikitextToMobileHtml with any type of body
func NewTransformWikitextToMobileHtmlRequestWithBody(server string, title string, params *TransformWikitextToMobileHtmlParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationPath, title)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transform/wikitext/to/mobile-html/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

		if params.OutputMode != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "output-mode", runtime.ParamLocationHeader, *params.OutputMode)
			if err != nil {
				return nil, err
			}

			req.Header.Set("output-mode", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCitationWithResponse request
	GetCitationWithResponse(ctx context.Context, format GetCitationParamsFormat, query string, params *GetCitationParams, reqEditors ...RequestEditorFn) (*GetCitationResponse, error)

	// GetDataCssMobileTypeWithResponse request
	GetDataCssMobileTypeWithResponse(ctx context.Context, pType GetDataCssMobileTypeParamsType, reqEditors ...RequestEditorFn) (*GetDataCssMobileTypeResponse, error)

	// GetDataI18nTypeWithResponse request
	GetDataI18nTypeWithResponse(ctx context.Context, pType GetDataI18nTypeParamsType, reqEditors ...RequestEditorFn) (*GetDataI18nTypeResponse, error)

	// GetDataJavascriptMobileTypeWithResponse request
	GetDataJavascriptMobileTypeWithResponse(ctx context.Context, pType GetDataJavascriptMobileTypeParamsType, reqEditors ...RequestEditorFn) (*GetDataJavascriptMobileTypeResponse, error)

	// GetDataListsWithResponse request
	GetDataListsWithResponse(ctx context.Context, params *GetDataListsParams, reqEditors ...RequestEditorFn) (*GetDataListsResponse, error)

	// PostDataListsWithBodyWithResponse request with any body
	PostDataListsWithBodyWithResponse(ctx context.Context, params *PostDataListsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDataListsResponse, error)

	// PostDataListsBatchWithBodyWithResponse request with any body
	PostDataListsBatchWithBodyWithResponse(ctx context.Context, params *PostDataListsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDataListsBatchResponse, error)

	// GetDataListsChangesSinceDateWithResponse request
	GetDataListsChangesSinceDateWithResponse(ctx context.Context, date time.Time, params *GetDataListsChangesSinceDateParams, reqEditors ...RequestEditorFn) (*GetDataListsChangesSinceDateResponse, error)

	// GetDataListsPagesProjectTitleWithResponse request
	GetDataListsPagesProjectTitleWithResponse(ctx context.Context, project string, title string, params *GetDataListsPagesProjectTitleParams, reqEditors ...RequestEditorFn) (*GetDataListsPagesProjectTitleResponse, error)

	// PostDataListsSetupWithResponse request
	PostDataListsSetupWithResponse(ctx context.Context, params *PostDataListsSetupParams, reqEditors ...RequestEditorFn) (*PostDataListsSetupResponse, error)

	// PostDataListsTeardownWithResponse request
	PostDataListsTeardownWithResponse(ctx context.Context, params *PostDataListsTeardownParams, reqEditors ...RequestEditorFn) (*PostDataListsTeardownResponse, error)

	// DeleteDataListsIdWithResponse request
	DeleteDataListsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteDataListsIdResponse, error)

	// PutDataListsIdWithBodyWithResponse request with any body
	PutDataListsIdWithBodyWithResponse(ctx context.Context, id int, params *PutDataListsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDataListsIdResponse, error)

	// GetListEntriesWithResponse request
	GetListEntriesWithResponse(ctx context.Context, id int, params *GetListEntriesParams, reqEditors ...RequestEditorFn) (*GetListEntriesResponse, error)

	// PostDataListsIdEntriesWithBodyWithResponse request with any body
	PostDataListsIdEntriesWithBodyWithResponse(ctx context.Context, id int, params *PostDataListsIdEntriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDataListsIdEntriesResponse, error)

	// PostDataListsIdEntriesBatchWithBodyWithResponse request with any body
	PostDataListsIdEntriesBatchWithBodyWithResponse(ctx context.Context, id int, params *PostDataListsIdEntriesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDataListsIdEntriesBatchResponse, error)

	// DeleteDataListsIdEntriesEntryIdWithResponse request
	DeleteDataListsIdEntriesEntryIdWithResponse(ctx context.Context, id int, entryId int, reqEditors ...RequestEditorFn) (*DeleteDataListsIdEntriesEntryIdResponse, error)

	// PostMediaMathCheckTypeWithBodyWithResponse request with any body
	PostMediaMathCheckTypeWithBodyWithResponse(ctx context.Context, pType PostMediaMathCheckTypeParamsType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMediaMathCheckTypeResponse, error)

	// GetMediaMathFormulaHashWithResponse request
	GetMediaMathFormulaHashWithResponse(ctx context.Context, hash string, reqEditors ...RequestEditorFn) (*GetMediaMathFormulaHashResponse, error)

	// GetMediaMathRenderFormatHashWithResponse request
	GetMediaMathRenderFormatHashWithResponse(ctx context.Context, format GetMediaMathRenderFormatHashParamsFormat, hash string, reqEditors ...RequestEditorFn) (*GetMediaMathRenderFormatHashResponse, error)

	// GetPageWithResponse request
	GetPageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPageResponse, error)

	// GetPageDataParsoidTitleRevisionTidWithResponse request
	GetPageDataParsoidTitleRevisionTidWithResponse(ctx context.Context, title string, revision int, tid string, params *GetPageDataParsoidTitleRevisionTidParams, reqEditors ...RequestEditorFn) (*GetPageDataParsoidTitleRevisionTidResponse, error)

	// GetPageDefinitionTermWithResponse request
	GetPageDefinitionTermWithResponse(ctx context.Context, term string, params *GetPageDefinitionTermParams, reqEditors ...RequestEditorFn) (*GetPageDefinitionTermResponse, error)

	// GetPageHtmlTitleWithResponse request
	GetPageHtmlTitleWithResponse(ctx context.Context, title string, params *GetPageHtmlTitleParams, reqEditors ...RequestEditorFn) (*GetPageHtmlTitleResponse, error)

	// GetFormatRevisionWithResponse request
	GetFormatRevisionWithResponse(ctx context.Context, title string, revision int, params *GetFormatRevisionParams, reqEditors ...RequestEditorFn) (*GetFormatRevisionResponse, error)

	// GetPageLintTitleWithResponse request
	GetPageLintTitleWithResponse(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*GetPageLintTitleResponse, error)

	// GetPageLintTitleRevisionWithResponse request
	GetPageLintTitleRevisionWithResponse(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*GetPageLintTitleRevisionResponse, error)

	// GetContentMediaListWithResponse request
	GetContentMediaListWithResponse(ctx context.Context, title string, params *GetContentMediaListParams, reqEditors ...RequestEditorFn) (*GetContentMediaListResponse, error)

	// GetContentWithRevisionMediaListWithResponse request
	GetContentWithRevisionMediaListWithResponse(ctx context.Context, title string, revision int, params *GetContentWithRevisionMediaListParams, reqEditors ...RequestEditorFn) (*GetContentWithRevisionMediaListResponse, error)

	// GetPageMobileHtmlOfflineResourcesTitleWithResponse request
	GetPageMobileHtmlOfflineResourcesTitleWithResponse(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*GetPageMobileHtmlOfflineResourcesTitleResponse, error)

	// GetPageMobileHtmlOfflineResourcesTitleRevisionWithResponse request
	GetPageMobileHtmlOfflineResourcesTitleRevisionWithResponse(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*GetPageMobileHtmlOfflineResourcesTitleRevisionResponse, error)

	// GetContentMobileHtmlWithResponse request
	GetContentMobileHtmlWithResponse(ctx context.Context, title string, params *GetContentMobileHtmlParams, reqEditors ...RequestEditorFn) (*GetContentMobileHtmlResponse, error)

	// GetContentWithRevisionMobileHtmlWithResponse request
	GetContentWithRevisionMobileHtmlWithResponse(ctx context.Context, title string, revision int, params *GetContentWithRevisionMobileHtmlParams, reqEditors ...RequestEditorFn) (*GetContentWithRevisionMobileHtmlResponse, error)

	// GetPageTitleTitleWithResponse request
	GetPageTitleTitleWithResponse(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*GetPageTitleTitleResponse, error)

	// GetPageTitleTitleRevisionWithResponse request
	GetPageTitleTitleRevisionWithResponse(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*GetPageTitleTitleRevisionResponse, error)

	// PostTransformHtmlToWikitextWithBodyWithResponse request with any body
	PostTransformHtmlToWikitextWithBodyWithResponse(ctx context.Context, params *PostTransformHtmlToWikitextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformHtmlToWikitextResponse, error)

	// PostTransformHtmlToWikitextTitleWithBodyWithResponse request with any body
	PostTransformHtmlToWikitextTitleWithBodyWithResponse(ctx context.Context, title string, params *PostTransformHtmlToWikitextTitleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformHtmlToWikitextTitleResponse, error)

	// PostTransformHtmlToWikitextTitleRevisionWithBodyWithResponse request with any body
	PostTransformHtmlToWikitextTitleRevisionWithBodyWithResponse(ctx context.Context, title string, revision int, params *PostTransformHtmlToWikitextTitleRevisionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformHtmlToWikitextTitleRevisionResponse, error)

	// PostTransformWikitextToHtmlWithBodyWithResponse request with any body
	PostTransformWikitextToHtmlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToHtmlResponse, error)

	// PostTransformWikitextToHtmlTitleWithBodyWithResponse request with any body
	PostTransformWikitextToHtmlTitleWithBodyWithResponse(ctx context.Context, title string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToHtmlTitleResponse, error)

	// PostTransformWikitextToHtmlTitleRevisionWithBodyWithResponse request with any body
	PostTransformWikitextToHtmlTitleRevisionWithBodyWithResponse(ctx context.Context, title string, revision int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToHtmlTitleRevisionResponse, error)

	// PostTransformWikitextToLintWithBodyWithResponse request with any body
	PostTransformWikitextToLintWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToLintResponse, error)

	PostTransformWikitextToLintWithResponse(ctx context.Context, body PostTransformWikitextToLintJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTransformWikitextToLintResponse, error)

	// PostTransformWikitextToLintTitleWithBodyWithResponse request with any body
	PostTransformWikitextToLintTitleWithBodyWithResponse(ctx context.Context, title string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToLintTitleResponse, error)

	// PostTransformWikitextToLintTitleRevisionWithBodyWithResponse request with any body
	PostTransformWikitextToLintTitleRevisionWithBodyWithResponse(ctx context.Context, title string, revision int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToLintTitleRevisionResponse, error)

	// TransformWikitextToMobileHtmlWithBodyWithResponse request with any body
	TransformWikitextToMobileHtmlWithBodyWithResponse(ctx context.Context, title string, params *TransformWikitextToMobileHtmlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransformWikitextToMobileHtmlResponse, error)
}

type GetCitationResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Result
	ApplicationproblemJSON404     *Problem
}

// Status returns HTTPResponse.Status
func (r GetCitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataCssMobileTypeResponse struct {
	Body                                                                    []byte
	HTTPResponse                                                            *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsCSS100200 *map[string]interface{}
	ApplicationproblemJSONDefault                                           *Problem
}

// Status returns HTTPResponse.Status
func (r GetDataCssMobileTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataCssMobileTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataI18nTypeResponse struct {
	Body                                                                     []byte
	HTTPResponse                                                             *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsi18n001200 *map[string]interface{}
	ApplicationproblemJSONDefault                                            *Problem
}

// Status returns HTTPResponse.Status
func (r GetDataI18nTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataI18nTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataJavascriptMobileTypeResponse struct {
	Body                                                                           []byte
	HTTPResponse                                                                   *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsJavaScript100200 *map[string]interface{}
	ApplicationproblemJSONDefault                                                  *Problem
}

// Status returns HTTPResponse.Status
func (r GetDataJavascriptMobileTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataJavascriptMobileTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataListsResponse struct {
	Body                                                                     []byte
	HTTPResponse                                                             *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsLists01200 *struct {
		// ContinueFrom Timestamp to sync from, to be used with the `GET /lists/changes/since/{date}`
		// endpoint.
		ContinueFrom *time.Time  `json:"continue-from,omitempty"`
		Lists        *[]ListRead `json:"lists,omitempty"`

		// Next Continuation token.
		Next *string `json:"next,omitempty"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetDataListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDataListsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		// Id List ID.
		//
		// Deprecated, will be removed. Use the full list object.
		Id   int      `json:"id"`
		List ListRead `json:"list"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostDataListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDataListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDataListsBatchResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		// Batch Deprecated, will be removed. Use the full list objects instead.
		Batch []struct {
			// Id List ID
			Id int `json:"id"`
		} `json:"batch"`
		Lists []ListRead `json:"lists"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostDataListsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDataListsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataListsChangesSinceDateResponse struct {
	Body                                                                     []byte
	HTTPResponse                                                             *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsLists01200 *struct {
		// ContinueFrom Timestamp to sync from, to be used with the `GET /lists/changes/since/{date}`
		// endpoint.
		ContinueFrom *time.Time  `json:"continue-from,omitempty"`
		Lists        *[]ListRead `json:"lists,omitempty"`

		// Next Continuation token.
		Next *string `json:"next,omitempty"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetDataListsChangesSinceDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataListsChangesSinceDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataListsPagesProjectTitleResponse struct {
	Body                                                                     []byte
	HTTPResponse                                                             *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsLists01200 *struct {
		Lists *[]ListRead `json:"lists,omitempty"`

		// Next Continuation token.
		Next *string `json:"next,omitempty"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetDataListsPagesProjectTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataListsPagesProjectTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDataListsSetupResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *map[string]interface{}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostDataListsSetupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDataListsSetupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDataListsTeardownResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *map[string]interface{}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostDataListsTeardownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDataListsTeardownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataListsIdResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *map[string]interface{}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteDataListsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataListsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDataListsIdResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		// Id List ID.
		//
		// Deprecated, will be removed. Use the full list object.
		Id   int      `json:"id"`
		List ListRead `json:"list"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PutDataListsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDataListsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListEntriesResponse struct {
	Body                                                                     []byte
	HTTPResponse                                                             *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsLists01200 *struct {
		Entries *[]ListEntryRead `json:"entries,omitempty"`

		// Next Continuation token.
		Next *string `json:"next,omitempty"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetListEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDataListsIdEntriesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		Entry ListEntryRead `json:"entry"`

		// Id List entry ID
		//
		// Deprecated, will be removed. Use the full entry object instead.
		Id int `json:"id"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostDataListsIdEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDataListsIdEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDataListsIdEntriesBatchResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		Batch []struct {
			// Id List entry ID
			Id *int `json:"id,omitempty"`
		} `json:"batch"`
		Entries []ListEntryRead `json:"entries"`
	}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostDataListsIdEntriesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDataListsIdEntriesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataListsIdEntriesEntryIdResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *map[string]interface{}
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteDataListsIdEntriesEntryIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataListsIdEntriesEntryIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMediaMathCheckTypeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON400     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostMediaMathCheckTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMediaMathCheckTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaMathFormulaHashResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetMediaMathFormulaHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaMathFormulaHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaMathRenderFormatHashResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetMediaMathRenderFormatHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaMathRenderFormatHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Listing
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageDataParsoidTitleRevisionTidResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *Problem
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageDataParsoidTitleRevisionTidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageDataParsoidTitleRevisionTidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageDefinitionTermResponse struct {
	Body                                                                           []byte
	HTTPResponse                                                                   *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsdefinition080200 *DefinitionsResponse
	ApplicationproblemJSON404                                                      *Problem
	ApplicationproblemJSON501                                                      *Problem
	ApplicationproblemJSONDefault                                                  *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageDefinitionTermResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageDefinitionTermResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageHtmlTitleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageHtmlTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageHtmlTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFormatRevisionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON400     *Problem
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetFormatRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFormatRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageLintTitleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON400     *Problem
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageLintTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageLintTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageLintTitleRevisionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON400     *Problem
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageLintTitleRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageLintTitleRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentMediaListResponse struct {
	Body                                                                      []byte
	HTTPResponse                                                              *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsMedia131200 *MediaList
	ApplicationproblemJSON404                                                 *Problem
	ApplicationproblemJSONDefault                                             *Problem
}

// Status returns HTTPResponse.Status
func (r GetContentMediaListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentMediaListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentWithRevisionMediaListResponse struct {
	Body                                                                      []byte
	HTTPResponse                                                              *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsMedia131200 *MediaList
	ApplicationproblemJSON404                                                 *Problem
	ApplicationproblemJSONDefault                                             *Problem
}

// Status returns HTTPResponse.Status
func (r GetContentWithRevisionMediaListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentWithRevisionMediaListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageMobileHtmlOfflineResourcesTitleResponse struct {
	Body                                                                                           []byte
	HTTPResponse                                                                                   *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsMobileHTMLOfflineResources121200 *string
	ApplicationproblemJSONDefault                                                                  *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageMobileHtmlOfflineResourcesTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageMobileHtmlOfflineResourcesTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageMobileHtmlOfflineResourcesTitleRevisionResponse struct {
	Body                                                                                           []byte
	HTTPResponse                                                                                   *http.Response
	ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsMobileHTMLOfflineResources121200 *string
	ApplicationproblemJSONDefault                                                                  *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageMobileHtmlOfflineResourcesTitleRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageMobileHtmlOfflineResourcesTitleRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentMobileHtmlResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetContentMobileHtmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentMobileHtmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentWithRevisionMobileHtmlResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetContentWithRevisionMobileHtmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentWithRevisionMobileHtmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageTitleTitleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Revision
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageTitleTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageTitleTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageTitleTitleRevisionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Revision
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r GetPageTitleTitleRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageTitleTitleRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformHtmlToWikitextResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformHtmlToWikitextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformHtmlToWikitextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformHtmlToWikitextTitleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformHtmlToWikitextTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformHtmlToWikitextTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformHtmlToWikitextTitleRevisionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformHtmlToWikitextTitleRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformHtmlToWikitextTitleRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformWikitextToHtmlResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformWikitextToHtmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformWikitextToHtmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformWikitextToHtmlTitleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformWikitextToHtmlTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformWikitextToHtmlTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformWikitextToHtmlTitleRevisionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON403     *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformWikitextToHtmlTitleRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformWikitextToHtmlTitleRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformWikitextToLintResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformWikitextToLintResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformWikitextToLintResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformWikitextToLintTitleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformWikitextToLintTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformWikitextToLintTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransformWikitextToLintTitleRevisionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *map[string]interface{}
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationproblemJSON410     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r PostTransformWikitextToLintTitleRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransformWikitextToLintTitleRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransformWikitextToMobileHtmlResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON404     *Problem
	ApplicationproblemJSONDefault *Problem
}

// Status returns HTTPResponse.Status
func (r TransformWikitextToMobileHtmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransformWikitextToMobileHtmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCitationWithResponse request returning *GetCitationResponse
func (c *ClientWithResponses) GetCitationWithResponse(ctx context.Context, format GetCitationParamsFormat, query string, params *GetCitationParams, reqEditors ...RequestEditorFn) (*GetCitationResponse, error) {
	rsp, err := c.GetCitation(ctx, format, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCitationResponse(rsp)
}

// GetDataCssMobileTypeWithResponse request returning *GetDataCssMobileTypeResponse
func (c *ClientWithResponses) GetDataCssMobileTypeWithResponse(ctx context.Context, pType GetDataCssMobileTypeParamsType, reqEditors ...RequestEditorFn) (*GetDataCssMobileTypeResponse, error) {
	rsp, err := c.GetDataCssMobileType(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataCssMobileTypeResponse(rsp)
}

// GetDataI18nTypeWithResponse request returning *GetDataI18nTypeResponse
func (c *ClientWithResponses) GetDataI18nTypeWithResponse(ctx context.Context, pType GetDataI18nTypeParamsType, reqEditors ...RequestEditorFn) (*GetDataI18nTypeResponse, error) {
	rsp, err := c.GetDataI18nType(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataI18nTypeResponse(rsp)
}

// GetDataJavascriptMobileTypeWithResponse request returning *GetDataJavascriptMobileTypeResponse
func (c *ClientWithResponses) GetDataJavascriptMobileTypeWithResponse(ctx context.Context, pType GetDataJavascriptMobileTypeParamsType, reqEditors ...RequestEditorFn) (*GetDataJavascriptMobileTypeResponse, error) {
	rsp, err := c.GetDataJavascriptMobileType(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataJavascriptMobileTypeResponse(rsp)
}

// GetDataListsWithResponse request returning *GetDataListsResponse
func (c *ClientWithResponses) GetDataListsWithResponse(ctx context.Context, params *GetDataListsParams, reqEditors ...RequestEditorFn) (*GetDataListsResponse, error) {
	rsp, err := c.GetDataLists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataListsResponse(rsp)
}

// PostDataListsWithBodyWithResponse request with arbitrary body returning *PostDataListsResponse
func (c *ClientWithResponses) PostDataListsWithBodyWithResponse(ctx context.Context, params *PostDataListsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDataListsResponse, error) {
	rsp, err := c.PostDataListsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDataListsResponse(rsp)
}

// PostDataListsBatchWithBodyWithResponse request with arbitrary body returning *PostDataListsBatchResponse
func (c *ClientWithResponses) PostDataListsBatchWithBodyWithResponse(ctx context.Context, params *PostDataListsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDataListsBatchResponse, error) {
	rsp, err := c.PostDataListsBatchWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDataListsBatchResponse(rsp)
}

// GetDataListsChangesSinceDateWithResponse request returning *GetDataListsChangesSinceDateResponse
func (c *ClientWithResponses) GetDataListsChangesSinceDateWithResponse(ctx context.Context, date time.Time, params *GetDataListsChangesSinceDateParams, reqEditors ...RequestEditorFn) (*GetDataListsChangesSinceDateResponse, error) {
	rsp, err := c.GetDataListsChangesSinceDate(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataListsChangesSinceDateResponse(rsp)
}

// GetDataListsPagesProjectTitleWithResponse request returning *GetDataListsPagesProjectTitleResponse
func (c *ClientWithResponses) GetDataListsPagesProjectTitleWithResponse(ctx context.Context, project string, title string, params *GetDataListsPagesProjectTitleParams, reqEditors ...RequestEditorFn) (*GetDataListsPagesProjectTitleResponse, error) {
	rsp, err := c.GetDataListsPagesProjectTitle(ctx, project, title, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataListsPagesProjectTitleResponse(rsp)
}

// PostDataListsSetupWithResponse request returning *PostDataListsSetupResponse
func (c *ClientWithResponses) PostDataListsSetupWithResponse(ctx context.Context, params *PostDataListsSetupParams, reqEditors ...RequestEditorFn) (*PostDataListsSetupResponse, error) {
	rsp, err := c.PostDataListsSetup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDataListsSetupResponse(rsp)
}

// PostDataListsTeardownWithResponse request returning *PostDataListsTeardownResponse
func (c *ClientWithResponses) PostDataListsTeardownWithResponse(ctx context.Context, params *PostDataListsTeardownParams, reqEditors ...RequestEditorFn) (*PostDataListsTeardownResponse, error) {
	rsp, err := c.PostDataListsTeardown(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDataListsTeardownResponse(rsp)
}

// DeleteDataListsIdWithResponse request returning *DeleteDataListsIdResponse
func (c *ClientWithResponses) DeleteDataListsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteDataListsIdResponse, error) {
	rsp, err := c.DeleteDataListsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataListsIdResponse(rsp)
}

// PutDataListsIdWithBodyWithResponse request with arbitrary body returning *PutDataListsIdResponse
func (c *ClientWithResponses) PutDataListsIdWithBodyWithResponse(ctx context.Context, id int, params *PutDataListsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDataListsIdResponse, error) {
	rsp, err := c.PutDataListsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDataListsIdResponse(rsp)
}

// GetListEntriesWithResponse request returning *GetListEntriesResponse
func (c *ClientWithResponses) GetListEntriesWithResponse(ctx context.Context, id int, params *GetListEntriesParams, reqEditors ...RequestEditorFn) (*GetListEntriesResponse, error) {
	rsp, err := c.GetListEntries(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListEntriesResponse(rsp)
}

// PostDataListsIdEntriesWithBodyWithResponse request with arbitrary body returning *PostDataListsIdEntriesResponse
func (c *ClientWithResponses) PostDataListsIdEntriesWithBodyWithResponse(ctx context.Context, id int, params *PostDataListsIdEntriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDataListsIdEntriesResponse, error) {
	rsp, err := c.PostDataListsIdEntriesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDataListsIdEntriesResponse(rsp)
}

// PostDataListsIdEntriesBatchWithBodyWithResponse request with arbitrary body returning *PostDataListsIdEntriesBatchResponse
func (c *ClientWithResponses) PostDataListsIdEntriesBatchWithBodyWithResponse(ctx context.Context, id int, params *PostDataListsIdEntriesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDataListsIdEntriesBatchResponse, error) {
	rsp, err := c.PostDataListsIdEntriesBatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDataListsIdEntriesBatchResponse(rsp)
}

// DeleteDataListsIdEntriesEntryIdWithResponse request returning *DeleteDataListsIdEntriesEntryIdResponse
func (c *ClientWithResponses) DeleteDataListsIdEntriesEntryIdWithResponse(ctx context.Context, id int, entryId int, reqEditors ...RequestEditorFn) (*DeleteDataListsIdEntriesEntryIdResponse, error) {
	rsp, err := c.DeleteDataListsIdEntriesEntryId(ctx, id, entryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataListsIdEntriesEntryIdResponse(rsp)
}

// PostMediaMathCheckTypeWithBodyWithResponse request with arbitrary body returning *PostMediaMathCheckTypeResponse
func (c *ClientWithResponses) PostMediaMathCheckTypeWithBodyWithResponse(ctx context.Context, pType PostMediaMathCheckTypeParamsType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMediaMathCheckTypeResponse, error) {
	rsp, err := c.PostMediaMathCheckTypeWithBody(ctx, pType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMediaMathCheckTypeResponse(rsp)
}

// GetMediaMathFormulaHashWithResponse request returning *GetMediaMathFormulaHashResponse
func (c *ClientWithResponses) GetMediaMathFormulaHashWithResponse(ctx context.Context, hash string, reqEditors ...RequestEditorFn) (*GetMediaMathFormulaHashResponse, error) {
	rsp, err := c.GetMediaMathFormulaHash(ctx, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaMathFormulaHashResponse(rsp)
}

// GetMediaMathRenderFormatHashWithResponse request returning *GetMediaMathRenderFormatHashResponse
func (c *ClientWithResponses) GetMediaMathRenderFormatHashWithResponse(ctx context.Context, format GetMediaMathRenderFormatHashParamsFormat, hash string, reqEditors ...RequestEditorFn) (*GetMediaMathRenderFormatHashResponse, error) {
	rsp, err := c.GetMediaMathRenderFormatHash(ctx, format, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaMathRenderFormatHashResponse(rsp)
}

// GetPageWithResponse request returning *GetPageResponse
func (c *ClientWithResponses) GetPageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPageResponse, error) {
	rsp, err := c.GetPage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageResponse(rsp)
}

// GetPageDataParsoidTitleRevisionTidWithResponse request returning *GetPageDataParsoidTitleRevisionTidResponse
func (c *ClientWithResponses) GetPageDataParsoidTitleRevisionTidWithResponse(ctx context.Context, title string, revision int, tid string, params *GetPageDataParsoidTitleRevisionTidParams, reqEditors ...RequestEditorFn) (*GetPageDataParsoidTitleRevisionTidResponse, error) {
	rsp, err := c.GetPageDataParsoidTitleRevisionTid(ctx, title, revision, tid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageDataParsoidTitleRevisionTidResponse(rsp)
}

// GetPageDefinitionTermWithResponse request returning *GetPageDefinitionTermResponse
func (c *ClientWithResponses) GetPageDefinitionTermWithResponse(ctx context.Context, term string, params *GetPageDefinitionTermParams, reqEditors ...RequestEditorFn) (*GetPageDefinitionTermResponse, error) {
	rsp, err := c.GetPageDefinitionTerm(ctx, term, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageDefinitionTermResponse(rsp)
}

// GetPageHtmlTitleWithResponse request returning *GetPageHtmlTitleResponse
func (c *ClientWithResponses) GetPageHtmlTitleWithResponse(ctx context.Context, title string, params *GetPageHtmlTitleParams, reqEditors ...RequestEditorFn) (*GetPageHtmlTitleResponse, error) {
	rsp, err := c.GetPageHtmlTitle(ctx, title, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageHtmlTitleResponse(rsp)
}

// GetFormatRevisionWithResponse request returning *GetFormatRevisionResponse
func (c *ClientWithResponses) GetFormatRevisionWithResponse(ctx context.Context, title string, revision int, params *GetFormatRevisionParams, reqEditors ...RequestEditorFn) (*GetFormatRevisionResponse, error) {
	rsp, err := c.GetFormatRevision(ctx, title, revision, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFormatRevisionResponse(rsp)
}

// GetPageLintTitleWithResponse request returning *GetPageLintTitleResponse
func (c *ClientWithResponses) GetPageLintTitleWithResponse(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*GetPageLintTitleResponse, error) {
	rsp, err := c.GetPageLintTitle(ctx, title, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageLintTitleResponse(rsp)
}

// GetPageLintTitleRevisionWithResponse request returning *GetPageLintTitleRevisionResponse
func (c *ClientWithResponses) GetPageLintTitleRevisionWithResponse(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*GetPageLintTitleRevisionResponse, error) {
	rsp, err := c.GetPageLintTitleRevision(ctx, title, revision, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageLintTitleRevisionResponse(rsp)
}

// GetContentMediaListWithResponse request returning *GetContentMediaListResponse
func (c *ClientWithResponses) GetContentMediaListWithResponse(ctx context.Context, title string, params *GetContentMediaListParams, reqEditors ...RequestEditorFn) (*GetContentMediaListResponse, error) {
	rsp, err := c.GetContentMediaList(ctx, title, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentMediaListResponse(rsp)
}

// GetContentWithRevisionMediaListWithResponse request returning *GetContentWithRevisionMediaListResponse
func (c *ClientWithResponses) GetContentWithRevisionMediaListWithResponse(ctx context.Context, title string, revision int, params *GetContentWithRevisionMediaListParams, reqEditors ...RequestEditorFn) (*GetContentWithRevisionMediaListResponse, error) {
	rsp, err := c.GetContentWithRevisionMediaList(ctx, title, revision, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentWithRevisionMediaListResponse(rsp)
}

// GetPageMobileHtmlOfflineResourcesTitleWithResponse request returning *GetPageMobileHtmlOfflineResourcesTitleResponse
func (c *ClientWithResponses) GetPageMobileHtmlOfflineResourcesTitleWithResponse(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*GetPageMobileHtmlOfflineResourcesTitleResponse, error) {
	rsp, err := c.GetPageMobileHtmlOfflineResourcesTitle(ctx, title, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageMobileHtmlOfflineResourcesTitleResponse(rsp)
}

// GetPageMobileHtmlOfflineResourcesTitleRevisionWithResponse request returning *GetPageMobileHtmlOfflineResourcesTitleRevisionResponse
func (c *ClientWithResponses) GetPageMobileHtmlOfflineResourcesTitleRevisionWithResponse(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*GetPageMobileHtmlOfflineResourcesTitleRevisionResponse, error) {
	rsp, err := c.GetPageMobileHtmlOfflineResourcesTitleRevision(ctx, title, revision, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageMobileHtmlOfflineResourcesTitleRevisionResponse(rsp)
}

// GetContentMobileHtmlWithResponse request returning *GetContentMobileHtmlResponse
func (c *ClientWithResponses) GetContentMobileHtmlWithResponse(ctx context.Context, title string, params *GetContentMobileHtmlParams, reqEditors ...RequestEditorFn) (*GetContentMobileHtmlResponse, error) {
	rsp, err := c.GetContentMobileHtml(ctx, title, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentMobileHtmlResponse(rsp)
}

// GetContentWithRevisionMobileHtmlWithResponse request returning *GetContentWithRevisionMobileHtmlResponse
func (c *ClientWithResponses) GetContentWithRevisionMobileHtmlWithResponse(ctx context.Context, title string, revision int, params *GetContentWithRevisionMobileHtmlParams, reqEditors ...RequestEditorFn) (*GetContentWithRevisionMobileHtmlResponse, error) {
	rsp, err := c.GetContentWithRevisionMobileHtml(ctx, title, revision, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentWithRevisionMobileHtmlResponse(rsp)
}

// GetPageTitleTitleWithResponse request returning *GetPageTitleTitleResponse
func (c *ClientWithResponses) GetPageTitleTitleWithResponse(ctx context.Context, title string, reqEditors ...RequestEditorFn) (*GetPageTitleTitleResponse, error) {
	rsp, err := c.GetPageTitleTitle(ctx, title, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageTitleTitleResponse(rsp)
}

// GetPageTitleTitleRevisionWithResponse request returning *GetPageTitleTitleRevisionResponse
func (c *ClientWithResponses) GetPageTitleTitleRevisionWithResponse(ctx context.Context, title string, revision int, reqEditors ...RequestEditorFn) (*GetPageTitleTitleRevisionResponse, error) {
	rsp, err := c.GetPageTitleTitleRevision(ctx, title, revision, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageTitleTitleRevisionResponse(rsp)
}

// PostTransformHtmlToWikitextWithBodyWithResponse request with arbitrary body returning *PostTransformHtmlToWikitextResponse
func (c *ClientWithResponses) PostTransformHtmlToWikitextWithBodyWithResponse(ctx context.Context, params *PostTransformHtmlToWikitextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformHtmlToWikitextResponse, error) {
	rsp, err := c.PostTransformHtmlToWikitextWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformHtmlToWikitextResponse(rsp)
}

// PostTransformHtmlToWikitextTitleWithBodyWithResponse request with arbitrary body returning *PostTransformHtmlToWikitextTitleResponse
func (c *ClientWithResponses) PostTransformHtmlToWikitextTitleWithBodyWithResponse(ctx context.Context, title string, params *PostTransformHtmlToWikitextTitleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformHtmlToWikitextTitleResponse, error) {
	rsp, err := c.PostTransformHtmlToWikitextTitleWithBody(ctx, title, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformHtmlToWikitextTitleResponse(rsp)
}

// PostTransformHtmlToWikitextTitleRevisionWithBodyWithResponse request with arbitrary body returning *PostTransformHtmlToWikitextTitleRevisionResponse
func (c *ClientWithResponses) PostTransformHtmlToWikitextTitleRevisionWithBodyWithResponse(ctx context.Context, title string, revision int, params *PostTransformHtmlToWikitextTitleRevisionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformHtmlToWikitextTitleRevisionResponse, error) {
	rsp, err := c.PostTransformHtmlToWikitextTitleRevisionWithBody(ctx, title, revision, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformHtmlToWikitextTitleRevisionResponse(rsp)
}

// PostTransformWikitextToHtmlWithBodyWithResponse request with arbitrary body returning *PostTransformWikitextToHtmlResponse
func (c *ClientWithResponses) PostTransformWikitextToHtmlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToHtmlResponse, error) {
	rsp, err := c.PostTransformWikitextToHtmlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformWikitextToHtmlResponse(rsp)
}

// PostTransformWikitextToHtmlTitleWithBodyWithResponse request with arbitrary body returning *PostTransformWikitextToHtmlTitleResponse
func (c *ClientWithResponses) PostTransformWikitextToHtmlTitleWithBodyWithResponse(ctx context.Context, title string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToHtmlTitleResponse, error) {
	rsp, err := c.PostTransformWikitextToHtmlTitleWithBody(ctx, title, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformWikitextToHtmlTitleResponse(rsp)
}

// PostTransformWikitextToHtmlTitleRevisionWithBodyWithResponse request with arbitrary body returning *PostTransformWikitextToHtmlTitleRevisionResponse
func (c *ClientWithResponses) PostTransformWikitextToHtmlTitleRevisionWithBodyWithResponse(ctx context.Context, title string, revision int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToHtmlTitleRevisionResponse, error) {
	rsp, err := c.PostTransformWikitextToHtmlTitleRevisionWithBody(ctx, title, revision, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformWikitextToHtmlTitleRevisionResponse(rsp)
}

// PostTransformWikitextToLintWithBodyWithResponse request with arbitrary body returning *PostTransformWikitextToLintResponse
func (c *ClientWithResponses) PostTransformWikitextToLintWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToLintResponse, error) {
	rsp, err := c.PostTransformWikitextToLintWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformWikitextToLintResponse(rsp)
}

func (c *ClientWithResponses) PostTransformWikitextToLintWithResponse(ctx context.Context, body PostTransformWikitextToLintJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTransformWikitextToLintResponse, error) {
	rsp, err := c.PostTransformWikitextToLint(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformWikitextToLintResponse(rsp)
}

// PostTransformWikitextToLintTitleWithBodyWithResponse request with arbitrary body returning *PostTransformWikitextToLintTitleResponse
func (c *ClientWithResponses) PostTransformWikitextToLintTitleWithBodyWithResponse(ctx context.Context, title string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToLintTitleResponse, error) {
	rsp, err := c.PostTransformWikitextToLintTitleWithBody(ctx, title, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformWikitextToLintTitleResponse(rsp)
}

// PostTransformWikitextToLintTitleRevisionWithBodyWithResponse request with arbitrary body returning *PostTransformWikitextToLintTitleRevisionResponse
func (c *ClientWithResponses) PostTransformWikitextToLintTitleRevisionWithBodyWithResponse(ctx context.Context, title string, revision int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransformWikitextToLintTitleRevisionResponse, error) {
	rsp, err := c.PostTransformWikitextToLintTitleRevisionWithBody(ctx, title, revision, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransformWikitextToLintTitleRevisionResponse(rsp)
}

// TransformWikitextToMobileHtmlWithBodyWithResponse request with arbitrary body returning *TransformWikitextToMobileHtmlResponse
func (c *ClientWithResponses) TransformWikitextToMobileHtmlWithBodyWithResponse(ctx context.Context, title string, params *TransformWikitextToMobileHtmlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransformWikitextToMobileHtmlResponse, error) {
	rsp, err := c.TransformWikitextToMobileHtmlWithBody(ctx, title, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransformWikitextToMobileHtmlResponse(rsp)
}

// ParseGetCitationResponse parses an HTTP response from a GetCitationWithResponse call
func ParseGetCitationResponse(rsp *http.Response) (*GetCitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Result
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/x-bibtex; charset=utf-8) unsupported

	}

	return response, nil
}

// ParseGetDataCssMobileTypeResponse parses an HTTP response from a GetDataCssMobileTypeWithResponse call
func ParseGetDataCssMobileTypeResponse(rsp *http.Response) (*GetDataCssMobileTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataCssMobileTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsCSS100200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetDataI18nTypeResponse parses an HTTP response from a GetDataI18nTypeWithResponse call
func ParseGetDataI18nTypeResponse(rsp *http.Response) (*GetDataI18nTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataI18nTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsi18n001200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetDataJavascriptMobileTypeResponse parses an HTTP response from a GetDataJavascriptMobileTypeWithResponse call
func ParseGetDataJavascriptMobileTypeResponse(rsp *http.Response) (*GetDataJavascriptMobileTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataJavascriptMobileTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsJavaScript100200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetDataListsResponse parses an HTTP response from a GetDataListsWithResponse call
func ParseGetDataListsResponse(rsp *http.Response) (*GetDataListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ContinueFrom Timestamp to sync from, to be used with the `GET /lists/changes/since/{date}`
			// endpoint.
			ContinueFrom *time.Time  `json:"continue-from,omitempty"`
			Lists        *[]ListRead `json:"lists,omitempty"`

			// Next Continuation token.
			Next *string `json:"next,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsLists01200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostDataListsResponse parses an HTTP response from a PostDataListsWithResponse call
func ParsePostDataListsResponse(rsp *http.Response) (*PostDataListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDataListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id List ID.
			//
			// Deprecated, will be removed. Use the full list object.
			Id   int      `json:"id"`
			List ListRead `json:"list"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostDataListsBatchResponse parses an HTTP response from a PostDataListsBatchWithResponse call
func ParsePostDataListsBatchResponse(rsp *http.Response) (*PostDataListsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDataListsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Deprecated, will be removed. Use the full list objects instead.
			Batch []struct {
				// Id List ID
				Id int `json:"id"`
			} `json:"batch"`
			Lists []ListRead `json:"lists"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetDataListsChangesSinceDateResponse parses an HTTP response from a GetDataListsChangesSinceDateWithResponse call
func ParseGetDataListsChangesSinceDateResponse(rsp *http.Response) (*GetDataListsChangesSinceDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataListsChangesSinceDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ContinueFrom Timestamp to sync from, to be used with the `GET /lists/changes/since/{date}`
			// endpoint.
			ContinueFrom *time.Time  `json:"continue-from,omitempty"`
			Lists        *[]ListRead `json:"lists,omitempty"`

			// Next Continuation token.
			Next *string `json:"next,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsLists01200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetDataListsPagesProjectTitleResponse parses an HTTP response from a GetDataListsPagesProjectTitleWithResponse call
func ParseGetDataListsPagesProjectTitleResponse(rsp *http.Response) (*GetDataListsPagesProjectTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataListsPagesProjectTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Lists *[]ListRead `json:"lists,omitempty"`

			// Next Continuation token.
			Next *string `json:"next,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsLists01200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostDataListsSetupResponse parses an HTTP response from a PostDataListsSetupWithResponse call
func ParsePostDataListsSetupResponse(rsp *http.Response) (*PostDataListsSetupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDataListsSetupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostDataListsTeardownResponse parses an HTTP response from a PostDataListsTeardownWithResponse call
func ParsePostDataListsTeardownResponse(rsp *http.Response) (*PostDataListsTeardownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDataListsTeardownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDataListsIdResponse parses an HTTP response from a DeleteDataListsIdWithResponse call
func ParseDeleteDataListsIdResponse(rsp *http.Response) (*DeleteDataListsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataListsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePutDataListsIdResponse parses an HTTP response from a PutDataListsIdWithResponse call
func ParsePutDataListsIdResponse(rsp *http.Response) (*PutDataListsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDataListsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id List ID.
			//
			// Deprecated, will be removed. Use the full list object.
			Id   int      `json:"id"`
			List ListRead `json:"list"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetListEntriesResponse parses an HTTP response from a GetListEntriesWithResponse call
func ParseGetListEntriesResponse(rsp *http.Response) (*GetListEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Entries *[]ListEntryRead `json:"entries,omitempty"`

			// Next Continuation token.
			Next *string `json:"next,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsLists01200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostDataListsIdEntriesResponse parses an HTTP response from a PostDataListsIdEntriesWithResponse call
func ParsePostDataListsIdEntriesResponse(rsp *http.Response) (*PostDataListsIdEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDataListsIdEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Entry ListEntryRead `json:"entry"`

			// Id List entry ID
			//
			// Deprecated, will be removed. Use the full entry object instead.
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostDataListsIdEntriesBatchResponse parses an HTTP response from a PostDataListsIdEntriesBatchWithResponse call
func ParsePostDataListsIdEntriesBatchResponse(rsp *http.Response) (*PostDataListsIdEntriesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDataListsIdEntriesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Batch []struct {
				// Id List entry ID
				Id *int `json:"id,omitempty"`
			} `json:"batch"`
			Entries []ListEntryRead `json:"entries"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDataListsIdEntriesEntryIdResponse parses an HTTP response from a DeleteDataListsIdEntriesEntryIdWithResponse call
func ParseDeleteDataListsIdEntriesEntryIdResponse(rsp *http.Response) (*DeleteDataListsIdEntriesEntryIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataListsIdEntriesEntryIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostMediaMathCheckTypeResponse parses an HTTP response from a PostMediaMathCheckTypeWithResponse call
func ParsePostMediaMathCheckTypeResponse(rsp *http.Response) (*PostMediaMathCheckTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMediaMathCheckTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetMediaMathFormulaHashResponse parses an HTTP response from a GetMediaMathFormulaHashWithResponse call
func ParseGetMediaMathFormulaHashResponse(rsp *http.Response) (*GetMediaMathFormulaHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaMathFormulaHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetMediaMathRenderFormatHashResponse parses an HTTP response from a GetMediaMathRenderFormatHashWithResponse call
func ParseGetMediaMathRenderFormatHashResponse(rsp *http.Response) (*GetMediaMathRenderFormatHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaMathRenderFormatHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageResponse parses an HTTP response from a GetPageWithResponse call
func ParseGetPageResponse(rsp *http.Response) (*GetPageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Listing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageDataParsoidTitleRevisionTidResponse parses an HTTP response from a GetPageDataParsoidTitleRevisionTidWithResponse call
func ParseGetPageDataParsoidTitleRevisionTidResponse(rsp *http.Response) (*GetPageDataParsoidTitleRevisionTidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageDataParsoidTitleRevisionTidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageDefinitionTermResponse parses an HTTP response from a GetPageDefinitionTermWithResponse call
func ParseGetPageDefinitionTermResponse(rsp *http.Response) (*GetPageDefinitionTermResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageDefinitionTermResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DefinitionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsdefinition080200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageHtmlTitleResponse parses an HTTP response from a GetPageHtmlTitleWithResponse call
func ParseGetPageHtmlTitleResponse(rsp *http.Response) (*GetPageHtmlTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageHtmlTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html; charset=utf-8; profile="https://www.mediawiki.org/wiki/Specs/HTML/2.1.0") unsupported

	}

	return response, nil
}

// ParseGetFormatRevisionResponse parses an HTTP response from a GetFormatRevisionWithResponse call
func ParseGetFormatRevisionResponse(rsp *http.Response) (*GetFormatRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFormatRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html; charset=utf-8; profile="https://www.mediawiki.org/wiki/Specs/HTML/2.1.0") unsupported

	}

	return response, nil
}

// ParseGetPageLintTitleResponse parses an HTTP response from a GetPageLintTitleWithResponse call
func ParseGetPageLintTitleResponse(rsp *http.Response) (*GetPageLintTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageLintTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageLintTitleRevisionResponse parses an HTTP response from a GetPageLintTitleRevisionWithResponse call
func ParseGetPageLintTitleRevisionResponse(rsp *http.Response) (*GetPageLintTitleRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageLintTitleRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetContentMediaListResponse parses an HTTP response from a GetContentMediaListWithResponse call
func ParseGetContentMediaListResponse(rsp *http.Response) (*GetContentMediaListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentMediaListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MediaList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsMedia131200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetContentWithRevisionMediaListResponse parses an HTTP response from a GetContentWithRevisionMediaListWithResponse call
func ParseGetContentWithRevisionMediaListResponse(rsp *http.Response) (*GetContentWithRevisionMediaListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentWithRevisionMediaListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MediaList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsMedia131200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageMobileHtmlOfflineResourcesTitleResponse parses an HTTP response from a GetPageMobileHtmlOfflineResourcesTitleWithResponse call
func ParseGetPageMobileHtmlOfflineResourcesTitleResponse(rsp *http.Response) (*GetPageMobileHtmlOfflineResourcesTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageMobileHtmlOfflineResourcesTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsMobileHTMLOfflineResources121200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageMobileHtmlOfflineResourcesTitleRevisionResponse parses an HTTP response from a GetPageMobileHtmlOfflineResourcesTitleRevisionWithResponse call
func ParseGetPageMobileHtmlOfflineResourcesTitleRevisionResponse(rsp *http.Response) (*GetPageMobileHtmlOfflineResourcesTitleRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageMobileHtmlOfflineResourcesTitleRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8ProfilehttpswwwMediawikiOrgwikiSpecsMobileHTMLOfflineResources121200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetContentMobileHtmlResponse parses an HTTP response from a GetContentMobileHtmlWithResponse call
func ParseGetContentMobileHtmlResponse(rsp *http.Response) (*GetContentMobileHtmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentMobileHtmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetContentWithRevisionMobileHtmlResponse parses an HTTP response from a GetContentWithRevisionMobileHtmlWithResponse call
func ParseGetContentWithRevisionMobileHtmlResponse(rsp *http.Response) (*GetContentWithRevisionMobileHtmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentWithRevisionMobileHtmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageTitleTitleResponse parses an HTTP response from a GetPageTitleTitleWithResponse call
func ParseGetPageTitleTitleResponse(rsp *http.Response) (*GetPageTitleTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageTitleTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Revision
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPageTitleTitleRevisionResponse parses an HTTP response from a GetPageTitleTitleRevisionWithResponse call
func ParseGetPageTitleTitleRevisionResponse(rsp *http.Response) (*GetPageTitleTitleRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageTitleTitleRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Revision
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformHtmlToWikitextResponse parses an HTTP response from a PostTransformHtmlToWikitextWithResponse call
func ParsePostTransformHtmlToWikitextResponse(rsp *http.Response) (*PostTransformHtmlToWikitextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformHtmlToWikitextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformHtmlToWikitextTitleResponse parses an HTTP response from a PostTransformHtmlToWikitextTitleWithResponse call
func ParsePostTransformHtmlToWikitextTitleResponse(rsp *http.Response) (*PostTransformHtmlToWikitextTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformHtmlToWikitextTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformHtmlToWikitextTitleRevisionResponse parses an HTTP response from a PostTransformHtmlToWikitextTitleRevisionWithResponse call
func ParsePostTransformHtmlToWikitextTitleRevisionResponse(rsp *http.Response) (*PostTransformHtmlToWikitextTitleRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformHtmlToWikitextTitleRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformWikitextToHtmlResponse parses an HTTP response from a PostTransformWikitextToHtmlWithResponse call
func ParsePostTransformWikitextToHtmlResponse(rsp *http.Response) (*PostTransformWikitextToHtmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformWikitextToHtmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformWikitextToHtmlTitleResponse parses an HTTP response from a PostTransformWikitextToHtmlTitleWithResponse call
func ParsePostTransformWikitextToHtmlTitleResponse(rsp *http.Response) (*PostTransformWikitextToHtmlTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformWikitextToHtmlTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformWikitextToHtmlTitleRevisionResponse parses an HTTP response from a PostTransformWikitextToHtmlTitleRevisionWithResponse call
func ParsePostTransformWikitextToHtmlTitleRevisionResponse(rsp *http.Response) (*PostTransformWikitextToHtmlTitleRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformWikitextToHtmlTitleRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformWikitextToLintResponse parses an HTTP response from a PostTransformWikitextToLintWithResponse call
func ParsePostTransformWikitextToLintResponse(rsp *http.Response) (*PostTransformWikitextToLintResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformWikitextToLintResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformWikitextToLintTitleResponse parses an HTTP response from a PostTransformWikitextToLintTitleWithResponse call
func ParsePostTransformWikitextToLintTitleResponse(rsp *http.Response) (*PostTransformWikitextToLintTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformWikitextToLintTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostTransformWikitextToLintTitleRevisionResponse parses an HTTP response from a PostTransformWikitextToLintTitleRevisionWithResponse call
func ParsePostTransformWikitextToLintTitleRevisionResponse(rsp *http.Response) (*PostTransformWikitextToLintTitleRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransformWikitextToLintTitleRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseTransformWikitextToMobileHtmlResponse parses an HTTP response from a TransformWikitextToMobileHtmlWithResponse call
func ParseTransformWikitextToMobileHtmlResponse(rsp *http.Response) (*TransformWikitextToMobileHtmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransformWikitextToMobileHtmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}
